#include "code_generator.h"
#include <iostream>
#include <map>

namespace vypr {

CodeGenerator::CodeGenerator(bool verbose) : verbose(verbose) {
    // Initialize opcode handlers
    opcodeHandlers[IROpCode::LOAD_CONST] = &CodeGenerator::handleLoadConst;
    opcodeHandlers[IROpCode::LOAD_VAR] = &CodeGenerator::handleLoadVar;
    opcodeHandlers[IROpCode::STORE_VAR] = &CodeGenerator::handleStoreVar;
    opcodeHandlers[IROpCode::BINARY_OP] = &CodeGenerator::handleBinaryOp;
    opcodeHandlers[IROpCode::UNARY_OP] = &CodeGenerator::handleUnaryOp;
    opcodeHandlers[IROpCode::JUMP] = &CodeGenerator::handleJump;
    opcodeHandlers[IROpCode::JUMP_IF_FALSE] = &CodeGenerator::handleJumpIfFalse;
    opcodeHandlers[IROpCode::JUMP_IF_TRUE] = &CodeGenerator::handleJumpIfTrue;
    opcodeHandlers[IROpCode::CALL] = &CodeGenerator::handleCall;
    opcodeHandlers[IROpCode::RETURN] = &CodeGenerator::handleReturn;
    opcodeHandlers[IROpCode::PRINT] = &CodeGenerator::handlePrint;
    opcodeHandlers[IROpCode::INPUT] = &CodeGenerator::handleInput;
    opcodeHandlers[IROpCode::ARRAY_NEW] = &CodeGenerator::handleArrayNew;
    opcodeHandlers[IROpCode::ARRAY_GET] = &CodeGenerator::handleArrayGet;
    opcodeHandlers[IROpCode::ARRAY_SET] = &CodeGenerator::handleArraySet;
    opcodeHandlers[IROpCode::MEMBER_GET] = &CodeGenerator::handleMemberGet;
    opcodeHandlers[IROpCode::LABEL] = &CodeGenerator::handleLabel;
    opcodeHandlers[IROpCode::NOP] = &CodeGenerator::handleNop;
}

void CodeGenerator::generate(const std::vector<IRFunction>& functions, const std::string& outputFile) {
    // Open output file
    outFile.open(outputFile);
    if (!outFile.is_open()) {
        throw std::runtime_error("Could not open output file: " + outputFile);
    }
    
    if (verbose) {
        std::cout << "Generating Python code to " << outputFile << std::endl;
    }
    
    // Write Python file header
    writeHeader();
    
    // Write functions
    for (const auto& function : functions) {
        writeFunction(function);
    }
    
    // Add main execution if there is a __main__ function
    outFile << "\n# Execute main function if this is the main module\n";
    outFile << "if __name__ == \"__main__\":\n";
    outFile << "    __main__()\n";
    
    // Close output file
    outFile.close();
    
    if (verbose) {
        std::cout << "Code generation complete." << std::endl;
    }
}

void CodeGenerator::writeHeader() {
    outFile << "#!/usr/bin/env python3\n";
    outFile << "# Generated by Vypr Compiler\n\n";
    
    // Import runtime libraries
    outFile << "import sys\n\n";
    
    // Define runtime helper functions
    outFile << "# Runtime helper functions\n";
    outFile << "def _vypr_concat(a, b):\n";
    outFile << "    return str(a) + str(b)\n\n";
    
    outFile << "def _vypr_input(prompt=\"\"):\n";
    outFile << "    if prompt:\n";
    outFile << "        sys.stdout.write(prompt)\n";
    outFile << "        sys.stdout.flush()\n";
    outFile << "    return input()\n\n";
}

void CodeGenerator::writeFunction(const IRFunction& function) {
    // Write function header
    outFile << "def " << function.name << "(";
    for (size_t i = 0; i < function.parameters.size(); ++i) {
        if (i > 0) outFile << ", ";
        outFile << function.parameters[i];
    }
    outFile << "):\n";
    
    // Write function body
    for (const auto& instr : function.instructions) {
        std::string code = (this->*opcodeHandlers.at(instr.opcode))(instr);
        outFile << getIndent(1) << code << "\n";
    }
}

void CodeGenerator::writeInstruction(const IRInstruction& instruction) {
    std::string code = (this->*opcodeHandlers.at(instruction.opcode))(instruction);
    outFile << code << "\n";
}

std::string CodeGenerator::handleLoadConst(const IRInstruction& instruction) {
    return instruction.operands[0] + " = " + instruction.operands[1];
}

std::string CodeGenerator::handleLoadVar(const IRInstruction& instruction) {
    return instruction.operands[0] + " = " + instruction.operands[1];
}

std::string CodeGenerator::handleStoreVar(const IRInstruction& instruction) {
    return instruction.operands[0] + " = " + instruction.operands[1];
}

std::string CodeGenerator::handleBinaryOp(const IRInstruction& instruction) {
    std::string result = instruction.operands[0];
    std::string left = instruction.operands[1];
    std::string op = instruction.operands[2];
    std::string right = instruction.operands[3];
    
    // Handle string concatenation specially
    if (op == "^") {
        return result + " = _vypr_concat(" + left + ", " + right + ")";
    }
    
    // Handle logical operators
    if (op == "&&") {
        op = "and";
    } else if (op == "||") {
        op = "or";
    } else if (op == "!") {
        op = "not";
    }
    
    return result + " = " + left + " " + op + " " + right;
}

std::string CodeGenerator::handleUnaryOp(const IRInstruction& instruction) {
    std::string result = instruction.operands[0];
    std::string op = instruction.operands[1];
    std::string operand = instruction.operands[2];
    
    // Convert logical not
    if (op == "!") {
        op = "not ";
    }
    
    return result + " = " + op + operand;
}

std::string CodeGenerator::handleJump(const IRInstruction& instruction) {
    return "_label = " + instruction.operands[0].substr(1);  // Remove 'L' prefix
}

std::string CodeGenerator::handleJumpIfFalse(const IRInstruction& instruction) {
    return "if not " + instruction.operands[0] + ":\n" + 
           getIndent(4) + "_label = " + instruction.operands[1].substr(1);  // Remove 'L' prefix
}

std::string CodeGenerator::handleJumpIfTrue(const IRInstruction& instruction) {
    return "if " + instruction.operands[0] + ":\n" + 
           getIndent(4) + "_label = " + instruction.operands[1].substr(1);  // Remove 'L' prefix
}

std::string CodeGenerator::handleCall(const IRInstruction& instruction) {
    std::string result = instruction.operands[0];
    std::string function = instruction.operands[1];
    std::string args = instruction.operands.size() > 2 ? instruction.operands[2] : "";
    
    return result + " = " + function + "(" + args + ")";
}

std::string CodeGenerator::handleReturn(const IRInstruction& instruction) {
    if (instruction.operands.empty()) {
        return "return";
    } else {
        return "return " + instruction.operands[0];
    }
}

std::string CodeGenerator::handlePrint(const IRInstruction& instruction) {
    return "print(" + instruction.operands[0] + ")";
}

std::string CodeGenerator::handleInput(const IRInstruction& instruction) {
    return instruction.operands[0] + " = _vypr_input()";
}

std::string CodeGenerator::handleArrayNew(const IRInstruction& instruction) {
    std::string result = instruction.operands[0];
    std::string elements = instruction.operands.size() > 1 ? instruction.operands[1] : "";
    
    return result + " = [" + elements + "]";
}

std::string CodeGenerator::handleArrayGet(const IRInstruction& instruction) {
    std::string result = instruction.operands[0];
    std::string array = instruction.operands[1];
    std::string index = instruction.operands[2];
    
    return result + " = " + array + "[" + index + "]";
}

std::string CodeGenerator::handleArraySet(const IRInstruction& instruction) {
    std::string array = instruction.operands[0];
    std::string index = instruction.operands[1];
    std::string value = instruction.operands[2];
    
    return array + "[" + index + "] = " + value;
}

std::string CodeGenerator::handleMemberGet(const IRInstruction& instruction) {
    std::string result = instruction.operands[0];
    std::string object = instruction.operands[1];
    std::string member = instruction.operands[2];
    
    // Special handling for array length
    if (member == "length") {
        return result + " = len(" + object + ")";
    }
    
    return result + " = " + object + "." + member;
}

std::string CodeGenerator::handleLabel(const IRInstruction& instruction) {
    // Labels are handled specially in writeFunction
    return "# Label " + instruction.operands[0];
}

std::string CodeGenerator::handleNop([[maybe_unused]] const IRInstruction& instruction) {
    return "pass";
}

std::string CodeGenerator::getIndent(int level) const {
    return std::string(level * 4, ' ');
}

std::string CodeGenerator::getPythonOperator(TokenType op) const {
    switch (op) {
        case TokenType::PLUS: return "+";
        case TokenType::MINUS: return "-";
        case TokenType::MULTIPLY: return "*";
        case TokenType::DIVIDE: return "/";
        case TokenType::CONCAT: return "_vypr_concat";
        case TokenType::EQUAL: return "==";
        case TokenType::NOT_EQUAL: return "!=";
        case TokenType::LESS: return "<";
        case TokenType::LESS_EQUAL: return "<=";
        case TokenType::GREATER: return ">";
        case TokenType::GREATER_EQUAL: return ">=";
        case TokenType::AND: return "and";
        case TokenType::OR: return "or";
        case TokenType::NOT: return "not";
        default: return "?";
    }
}

} // namespace vypr 